<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> Closure question</title>
</head>
<body>
    <h2>good morning</h2>
    <script>
        // Q->1 : What will be logged to console

        // let count = 0;
        // (function printCount(){

        //     if(count === 0){
        //         let count = 1; // shadowing
        //         console.log(count);
        //     }
        //     // count =0
        //     console.log(count);

        // })();


        // que-2 write a function that would alow you to do this

        // function createbase(num){
        //     return  function (innerNum){
        //         console.log(innerNum + num);
        //     }
        // }

        // var addSix = createbase(6);
        // addSix(10);
        // addSix(15);

        // que-> 3 time optimization

        //  function find(){
        //     let a=[];
        //     for(let i=0;i<1000000000;i++){
        //         a[i] =  i * i ;

        //     }

        //     return function (index){
        //         console.log(a[index]);
        //     };
        //  }

        //  const closure =find();
        //  console.time("6");

        //  console.log(6);
        //  console.timeEnd("6");
        //  console.time("50");
        //  closure(50);


    // q->(4)  Block scope & setTimeout
    // function a(){
    //     for(var i=0; i<3 ; i++){
    //         setTimeout(function(){
    //             console.log(i);
    //         } , i * 1000);
    //     }
    // }
    
    // // 3
    // // 3
    // // 3
    // a();

    // function a(){
    //     for(let i=0; i<3 ; i++){
    //         setTimeout(function(){
    //             console.log(i);
    //         } , i * 1000);
    //     }
    // }
    
    // // 0
    // // 1
    // // 2
    // a();


    // for(var i=0; i<3 ; i++){

    //     function inner(i){
    //         setTimeout(function(){
    //             console.log(i);
    //         } , i * 1000);
    //     }

    //     inner(i);
    // }


    // q->(5) how would you use a closure to create a private counter

//     function counter(){
//         var _counter = 0;

//         function add(increment){
//             _counter += increment;
//         }

//         function retrive(){
//             return "Counter = " + _counter
//         }

//         return {
//             add,
//             retrive,
//         }
//     }
//     const c = counter();
//     c.add(5);
//     c.add(10);

//   console.log( retrive());

// Q- what is module patten ?

// var module =(function (){

//     function privateMethod(){
//         console.log("private");
//     }

//     return {
//         publicMethod: function(){
//             console.log("public");
//         },
        
//     };
// }) ();

// module.publicMethod();
// module.privateMethod();

// Q-> (7)make this run only once

// let view;

// function likeTheVideo(){
//     let called = 0;
    
//     return function(){
//         if(called > 0){
            
//             console.log("already subscribed to roadside coder");
//         }
        
//         else{
//             view = "Roadside Coder";
//             console.log("subscribed to" , view);
//             called++;
//         }
//     }
// }

// let isSubscribed = likeTheVideo();

// isSubscribed();
// isSubscribed();
// isSubscribed();
// isSubscribed();


// Q->(8) once polyfill

// function once(func , context){
//     let ran;

//     return  function(){
//         if(func){
//             ran = func.apply(context || this , arguments);
//             func = null;
//         }

//         return ran;
//     }
// }

// const hello =once((a,b)=> console.log("hello" , a,b));

// hello(1,2);
// hello();
// hello();


// Ques ->9 : Memorize polyfill

function myMemorize(fn, context){
    const res = {};

    return function (...args){
        var argCache = JSON.stringify(...args);

        if(!res[argCache]){
            res[argCache] = fn.call(context || this , ...args);
        }

        return res[argCache];
    
    }
}


const clumsysquare = (num1, num2) => {
    for(let i=1; i<= 100000000; i++){}

    return num1 * num2;
}


const memorizedClumsysquare = myMemorize(clumsysquare);
   
  console.time("First call");
  console.log(clumsysquare( 9467 , 7649));
  console.timeEnd("First call");

  console.time("Second call");
  console.log(clumsysquare( 9467 , 7649));
  console.timeEnd("Second call");

//   que-10 what is different between closure  & scope

</script>
</body>
</html>